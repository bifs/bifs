diff --git a/.gitignore b/.gitignore
index 37fc9d4..e7b0598 100644
--- a/.gitignore
+++ b/.gitignore
@@ -88,3 +88,8 @@ ENV/
 
 # Rope project settings
 .ropeproject
+/.vs
+/bifs/src/PET2_nifti.out
+/ep1_compressed.npz
+/ep1.npz
+/bifs/src/ep1.npz
diff --git a/bifs/src/bifs.py b/bifs/src/bifs.py
index 39ed5e5..bd9584d 100644
--- a/bifs/src/bifs.py
+++ b/bifs/src/bifs.py
@@ -4,6 +4,10 @@
 ###         Class for performing Bayesian Image         ###
 ###         Restoration in Fourier Space (BIFS)         ###
 
+# for debugging
+import traceback
+
+
 import numpy as np
 import scipy as sp
 import matplotlib.pyplot as plt
@@ -287,6 +291,27 @@ class bifs:
             param_file.close()
             return
 
+    def copy_params(self):
+        """
+
+        Return a new bifs object that has all the basic parameter values found in self.
+
+        Does not copy the image or filename
+        """
+        newbifs = bifs()
+        newbifs.param_func_type = self.param_func_type
+        newbifs.decay = self.decay
+        newbifs.prior = self.prior
+        newbifs.prior_scale = self.prior_scale
+        newbifs.likelihood = self.likelihood
+        newbifs.likelihood_scale = self.likelihood_scale
+        newbifs.bumps = self.bumps
+        newbifs.view3Dslice = self.view3Dslice
+        if hasattr(self, "prior_mean"):
+            newbifs.prior_mean = self.prior_mean
+            newbifs.prior_std = self.prior_std
+        return newbifs
+
 
     def load_image_file(self,fileName):
         """
@@ -300,6 +325,8 @@ class bifs:
         Outputs:
           loads file into bifs object
 
+        RB makes read_imfile persistent in some cases so bulk scans can get the headers.
+
         """
         self.initial_image_file_name = fileName
         try:
@@ -320,17 +347,17 @@ class bifs:
                     # nibabel.streamlines.is_supported(fname) would seem to be a good test, but files
                     # that fail it can still be read, e.g., nii.gz files.
                     # So we use the Python idiom "Better to ask forgiveness than permission"
-                    read_imfile = nibabel.load(self.initial_image_file_name)
-                    read_image = read_imfile.get_fdata()
+                    self.read_imfile = nibabel.load(self.initial_image_file_name)
+                    read_image = self.read_imfile.get_fdata()
                 except:
                     try:
-                        read_imfile = imageio.volread(self.initial_image_file_name)
-                        assert len(read_imfile) > 2
-                        read_image = np.asarray(read_imfile)
+                        self.read_imfile = imageio.volread(self.initial_image_file_name)
+                        assert len(self.read_imfile) > 2
+                        read_image = np.asarray(self.read_imfile)
                     except:
                         # we have a 2D, or maybe 1D, image
-                        read_imfile = imageio.imread(self.initial_image_file_name)
-                        read_image = np.asarray(read_imfile)
+                        self.read_imfile = imageio.imread(self.initial_image_file_name)
+                        read_image = np.asarray(self.read_imfile)
             self.image_file_loaded = True
             self.load_image(read_image)
         except:
@@ -359,6 +386,7 @@ class bifs:
 
         """
         self.init_image = init_image
+        self.init_image[np.isnan(init_image)] = 0.0
         self.final_image = 0
         self.bifsk_image = 0
         self.imdim = len(init_image.shape)
@@ -484,6 +512,12 @@ class bifs:
                     self.prior_mean = self.bas.linsc(self.bvec,self.kdist)
                     self.prior_std = self.prior_scale*self.prior_mean # default for now
                                                         # i.e. strong prior
+                elif pft == "Empirical":
+                    # should already have loaded prior_mean and prior_std
+                    self.prior_std *= self.prior_scale
+                    # ugly: this is done elsewhere for all other types
+                    # which is weird since we reset the sd for some of the other types just above
+                    self.prior_std2 = self.prior_std*self.prior_std
                 else:
                     print("Please specify recognized transform space parameter function, one of:")
                     for pf in self.param_func_choices:
@@ -513,6 +547,17 @@ class bifs:
             else:
                 pass
         return
+
+    def load_empirical(self, fname):
+        """Load empirical prior from named file and set mode to Empirical
+        Also sets prior scale to 1, since the default value is very small.
+        You can and probably should make it larger via the Gaussian gui specification.
+        """
+        x = np.load(fname)
+        self.prior_mean = x["mean"]
+        self.prior_std = x["sd"]
+        self.param_func_type = "Empirical"
+        self.prior_scale = 1.0
      
     def bifs_map_gauss_gauss(self,pm,ps2,mf,ds2):
         """
@@ -619,9 +664,10 @@ class bifs:
             return
         else:
             # In case prior scale was reset:
-            self.prior_std[np.where(self.prior_mean != 0.0)] = self.prior_scale*self.prior_mean[np.where(self.prior_mean != 0.0)]
-            self.prior_std[np.where(self.prior_mean == 0.0)] = self.prior_scale*self.prior_mean_init
-            self.prior_std2 = self.prior_std*self.prior_std
+            if self.param_func_type != "Empirical":
+                self.prior_std[np.where(self.prior_mean != 0.0)] = self.prior_scale*self.prior_mean[np.where(self.prior_mean != 0.0)]
+                self.prior_std[np.where(self.prior_mean == 0.0)] = self.prior_scale*self.prior_mean_init
+                self.prior_std2 = self.prior_std*self.prior_std
 
             # In case parameter function or decay value were reset:
             self.set_prior_from_param_func(self.param_func_type)
diff --git a/bifs/src/bifs_gui.py b/bifs/src/bifs_gui.py
index 4c1ca58..df48bc2 100644
--- a/bifs/src/bifs_gui.py
+++ b/bifs/src/bifs_gui.py
@@ -12,6 +12,7 @@ except:
     newProfile = False
 
 from PyQt5 import QtGui, QtWidgets, QtCore
+from PyQt5.QtWidgets import QMessageBox
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.figure import Figure
 from matplotlib.colors import NoNorm 
@@ -21,11 +22,19 @@ import numpy as np
 from scipy import misc
 import bifs
 import jsonpickle
+import os
+import itertools
 
 from pset_dialogs import Param_Fourier_Space_Dialog,Prior_Dialog
 from pset_dialogs import Likelihood_Dialog,Slice3D_Dialog
 from pset_dialogs import AddBump_Dialog,DeleteBump_Dialog
 
+# gastly hack
+# but currently if this is run in debug mode it has a different working directory than
+# if run from command line.  To avoid problems, hard code whole path.
+# Empirical Prior file
+EPFILE = r"C:\Users\rdboylan\Documents\Kornak\bifs\bifs\src\ep2.npz"
+
 class MainWindow(QtWidgets.QMainWindow):
     """
 
@@ -80,7 +89,163 @@ class MainWindow(QtWidgets.QMainWindow):
         else:
             # runs in Python 3.6
             prof.strip_dirs().sort_stats("cumulative").print_stats(15)
-        
+
+    def getEmpiricalPrior(self):
+        """
+
+        Prompt for root directory of images.
+        Scan each, FFT, and get mean and sd of values in k-space
+        """
+        docDir = QtCore.QStandardPaths.standardLocations(QtCore.QStandardPaths.DocumentsLocation)[0]
+        topDirDlg = QtWidgets.QFileDialog(self, caption="Top Directory for Images",
+                                         directory = docDir)
+        topDirDlg.setFileMode(QtWidgets.QFileDialog.Directory)
+        if topDirDlg.exec_():
+            topDir = topDirDlg.selectedFiles()[0]
+        else:
+            return
+
+        ## profiling
+        pr = cProfile.Profile()
+        pr.enable()
+
+        ## actual computation
+        if self._scanImages(topDir):
+            self._statsPost()
+        else:
+            # something funky in images
+            pass
+
+        ## end profiling
+        pr.disable()
+        prof = pstats.Stats(pr)
+        if newProfile:
+            #next if for Python 3.7+
+            prof.strip_dirs().sort_stats(SortKey.CUMULATIVE).print_stats(15)
+        else:
+            # runs in Python 3.6
+            prof.strip_dirs().sort_stats("cumulative").print_stats(15)
+
+    def _scanImages(self, rootDir):
+        """
+        Read in all the images under rootDir
+        Fourier transform them
+
+        self._mbifs  is a collection of the resulting bifs objects
+
+        If headers of images are inconsistent, report error and return False.
+        Otherwise return True.
+
+        May operate in parallel.
+        """
+
+        self.nImages = 0
+        benchmarkHdr = None
+        mismatch = set()  # holds keys that had a mismatch
+
+        for root, dirs, files in os.walk(rootDir):
+            # avoid our target case for whom we are trying to predict
+            iKill = [ i for i, d in zip(itertools.count(), dirs) if d.find("10933")>=0]
+            if iKill:
+                nKill = 0
+                for i in iKill:
+                    i -= nKill
+                    print("Skipping {}".format(dirs[i]))
+                    del dirs[i-nKill]
+                    nKill += 1
+            # look for files to import
+            if files:
+                for f in files:
+                    #if not f.endswith(".nii"):
+                    if not f == "suvr_pons.nii":
+                        continue
+                    self.nImages += 1
+                    b = self.mybifs.copy_params()
+                    b.load_image_file(os.path.join(root, f))
+                    self._statsAccumulate(b.mod_image)
+                    hdr = b.read_imfile.header
+                    del b
+                    if not benchmarkHdr:
+                        # first header encountered
+                        benchmarkHdr = hdr
+                        # could not delete the following key
+                        # it actually doesn't appear in the objects attributes
+                        #del benchmarkHdr.__dict__['db_name']  # differences expected and no concern
+                    else:
+                        for key in benchmarkHdr:
+                            if key == 'db_name':
+                                continue
+
+                            if key.startswith("scl_"):
+                                # values were array(nan, dtype=float32) and I had no luck testing for them
+                                # in various ways
+                                continue
+                            v1 = benchmarkHdr[key]
+                            v2 = hdr[key]
+                            if (v1 != v2).any():
+                                mismatch.add(key)
+        if mismatch:
+            msgb = QMessageBox()
+            msgb.setText("Warning: The following keys were not uniform in the files scanned: {}.".format(mismatch))
+            msgb.setInformativeText("Do you want to proceed anyway?")
+            msgb.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
+            msgb.setIcon(QMessageBox.Warning)
+            msgb.setDefaultButton(QMessageBox.No)
+            return msgb.exec() == QMessageBox.Yes
+        return True
+
+    def _statsAccumulate(self, m):
+        """
+        Accumulate running statistics on the values of m in different images
+        self.nImages gives the current image number; it starts at 1.
+        m is ordinarily the modulus, and must conform to numpy array protocols
+
+        Updates self._mns and self._ss currently.
+        """
+        if self.nImages == 1:
+            self._mns = m
+            # ss will turn into a matrix later
+            self._ss = 0.0
+        else:
+            lastdelta = m-self._mns
+            self._mns += (lastdelta)/self.nImages
+            # element by element multiplication in next line
+            self._ss += lastdelta*(m-self._mns)
+
+    def _statsPost(self):
+        """
+        Finalize computation of voxel by voxel statistics for all images.
+        Call after all images have been seen.
+
+        Results returned as arrays self.mns and self.sds.
+        Also writes these results to disk.
+
+        Note the assumption that all images have the same dimensions.
+        Also, images should be aligned with each other for this to be meaningful
+
+        """
+        self.mns = self._mns
+        # element by element square root
+        self.sds = np.sqrt(self._ss/(self.nImages-1))
+        del self._mns
+        del self._ss
+        np.savez(EPFILE, mean=self.mns, sd=self.sds)
+        print("{} has means and sds for modulus of {} PET scans".format(EPFILE, self.nImages))
+        #np.savez_compressed("ep1_compressed.npz", mean=mns, sd=sds)
+
+    def loadEmpiricalPrior(self):
+        """
+        Load a previously computed empirical prior and use it as the prior for image reconstruction.
+
+        getEmpiricalPrior scans through directories of images to build up the prior.
+        Ultimately it saves the mean and sd of the modulus, as seen in the code immediately above.
+
+        In contrast, this function reads those values that were written out and instructs
+        mybifs to use those, rather than functional shortcuts, for the prior in reconstructing
+        a particular image.
+        """
+        self.mybifs.load_empirical(EPFILE)
+
     def getImage_real(self):
         """
     
@@ -89,8 +254,16 @@ class MainWindow(QtWidgets.QMainWindow):
 
         """
         # self.__init__()
+
+        # for ease of development, pre-specify a file
+        # next 2 lines are the original code
+        #self.fileName = QtWidgets.QFileDialog.getOpenFileName(self, "Open File",
+        #                                             QtCore.QDir.currentPath())[0]
+        #testFile = r"C:\Users\rdboylan\Documents\Kornak\ADNI\PET1\002_S_2010\Tx_Origin,_Spatially_Normalized" + \
+        #    r"\2010-07-14_08_30_16.0\I210121\ADNI_002_S_2010_MR_Tx_Origin,_Spatially_Normalized_Br_20110110222232802_S89021_I210121.nii"
+        testFile = r"C:\Users\rdboylan\Documents\Kornak\ExternalData\ycobigo\ASL\ana_res-2019-02-21_SPM\CBF\CBF_T1_10933_2012-09-21.nii.gz"
         self.fileName = QtWidgets.QFileDialog.getOpenFileName(self, "Open File",
-                                                     QtCore.QDir.currentPath())[0]
+                                                     testFile)[0]
         # Qt docs say return value is a string, but it is tuple whose first element we want
 
         try:
@@ -117,25 +290,14 @@ class MainWindow(QtWidgets.QMainWindow):
             #try:
             print("Performing k-space MAP estimation")
             # Reinitialize bifs object but keep current parameter setttings
-            pft = self.mybifs.param_func_type
-            dec = self.mybifs.decay
-            pri = self.mybifs.prior
-            prs = self.mybifs.prior_scale
-            lik = self.mybifs.likelihood
-            lis = self.mybifs.likelihood_scale
-            bps = self.mybifs.bumps
-            v3d = self.mybifs.view3Dslice
-            self.mybifs = bifs.bifs()
+            # RB: I refactored the parameter copying to the bifs object itself.
+            # However, this means I set the parameters and then load the image file.
+            # The original code loaded the image file and then set the parameters.
+            # Since I don't understand why the reinitialization was necessary at all,
+            # it's possible this change in sequence will break something.
+            self.mybifs = self.mybifs.copy_params()
             self.mybifs.load_image_file(self.fileName)
             self.mybifs.image_file_loaded = True
-            self.mybifs.param_func_type = pft
-            self.mybifs.decay = dec
-            self.mybifs.prior = pri
-            self.mybifs.prior_scale = prs
-            self.mybifs.likelihood = lik
-            self.mybifs.likelihood_scale = lis
-            self.mybifs.bumps = bps
-            self.mybifs.view3Dslice = v3d
             self.mybifs.BIFS_MAP()
             self.didMAP = True
             self.show_post_proc_images()
@@ -336,6 +498,10 @@ class MainWindow(QtWidgets.QMainWindow):
         
         self.getImageAct = QtWidgets.QAction("&Load Initial Image...", self, triggered=self.getImage)
 
+        self.getEmpiricalPriorAct = QtWidgets.QAction("&Empirical Prior...", self, triggered=self.getEmpiricalPrior)
+
+        self.loadEmpiricalPriorAct = QtWidgets.QAction("&Load Empirical Prior", self, triggered=self.loadEmpiricalPrior)
+
         self.doMapAct = QtWidgets.QAction("&Get MAP Estimate Image...", self,triggered=self.doMAP)
 
         self.saveCurrentAct = QtWidgets.QAction("&Save Current Results...", self,triggered=self.saveCurrent)
@@ -366,6 +532,7 @@ class MainWindow(QtWidgets.QMainWindow):
     def createMenus(self):
         self.bifsMenu = QtWidgets.QMenu("&BIFS Operations", self)
         self.bifsMenu.addAction(self.getImageAct)
+        self.bifsMenu.addAction(self.getEmpiricalPriorAct)
         self.bifsMenu.addAction(self.doMapAct)
         self.bifsMenu.addAction(self.saveCurrentAct)
         self.bifsMenu.addAction(self.loadPreviousAct)
@@ -373,6 +540,7 @@ class MainWindow(QtWidgets.QMainWindow):
         self.bifsMenu.addAction(self.exitAct)
 
         self.paramMenu = QtWidgets.QMenu("&Parameter Set", self)
+        self.paramMenu.addAction(self.loadEmpiricalPriorAct)
         self.paramMenu.addAction(self.setParamFuncAct)
         self.paramMenu.addAction(self.setPriorAct)
         self.paramMenu.addAction(self.setLikelihoodAct)
diff --git a/bifs/src/scan.py b/bifs/src/scan.py
new file mode 100644
index 0000000..42b796e
--- /dev/null
+++ b/bifs/src/scan.py
@@ -0,0 +1,58 @@
+import os
+import numpy as np
+import nibabel as nib
+from math import isnan
+import sys
+
+
+IMAGETOP = r"C:\Users\rdboylan\Documents\Kornak\ExternalData\ycobigo\registered"
+#IMAGETOP = r"C:\Users\rdboylan\Documents\Kornak\ADNI\PET1"
+
+def do_scan(theDir):
+    mismatch = set()  # holds keys that had a mismatch
+    benchmarkHdr = None
+    for root, dirs, files in os.walk(theDir):
+        if files:
+            print("Dir {}:".format(root))
+            for f in files:
+                print("\t{}".format(f))
+                if not (f.endswith(".nii") or f.endswith(".nii.gz")):
+                    continue
+                img = nib.load(os.path.join(root, f))
+                hdr = img.header
+                print("\t  Shape: {}.  Transform: {}.  Zooms: {}".format(img.shape, img.affine.shape,
+                                                                         hdr.get_zooms()))
+                if not benchmarkHdr:
+                    # first header encountered
+                    benchmarkHdr = hdr
+                    # could not delete the following key
+                    # it actually doesn't appear in the objects attributes
+                    #del benchmarkHdr.__dict__['db_name']  # differences expected and no concern
+                    print("\t  {}".format(hdr))
+                else:
+                    for key in benchmarkHdr:
+                        if key == 'db_name':
+                            continue
+
+                        if key.startswith("scl_"):
+                            # values were array(nan, dtype=float32) and I had no luck testing for them
+                            # in various ways
+                            continue
+                        v1 = benchmarkHdr[key]
+                        v2 = hdr[key]
+                        if (v1 != v2).any():
+                            mismatch.add(key)
+                            print("\t  {}:{}".format(key, hdr[key]))
+                print("\n")
+
+    if mismatch:
+        print("The following keys were not uniform in the files scanned: {}.".format(mismatch))
+    else:
+        print("Header keys are consistent across all images scanned.")
+
+
+if __name__== "__main__":
+    for dir in sys.argv[1:]:
+        do_scan(dir)
+else:
+    do_scan(IMAGETOP)
diff --git a/bifs/src/viewer.py b/bifs/src/viewer.py
new file mode 100644
index 0000000..d4d482e
--- /dev/null
+++ b/bifs/src/viewer.py
@@ -0,0 +1,34 @@
+
+import numpy as np
+from mayavi import mlab
+from time import sleep
+
+DATFILE=r"C:\Users\rdboylan\Documents\Kornak\bifs\bifs\src\ep1.npz"
+x = np.load(DATFILE)
+m = x["mean"]
+sd = x["sd"]
+x.close()
+aSlice = mlab.volume_slice(m)
+iMin = np.min(m.shape)
+# we know it will be the x axis
+iMin = m.shape[0]
+m0 = m
+#m = np.zeros_like(m0)
+#m[m0>100] = 1.0
+m = np.log(m0)
+mlab.pipeline.volume(mlab.pipeline.scalar_field(m))
+mlab.show_pipeline()
+#mlab.show()
+
+@mlab.animate(delay=200)
+def anim():
+    for i in range(iMin):
+        aSlice.ipw.slice_index = i
+        #mlab.process_ui_events()
+        yield
+
+mlab.outline()
+mlab.orientation_axes()
+anim()
+mlab.show()
+x=None
\ No newline at end of file
